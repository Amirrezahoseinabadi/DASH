// =================================================================================
// Â  Â  Â  Â  Ú©Ø¯ Ù†Ù‡Ø§ÛŒÛŒ Ø±Ø¨Ø§Øª Ø¬Ø´Ù†ÙˆØ§Ø±Ù‡ ØªØ§Ø¨Ø³ØªØ§Ù†ÛŒ - Ù†Ø³Ø®Ù‡ 29 (Ø§ÙØ²ÙˆØ¯Ù† API Ú©Ø§Ø±Ø¨Ø± Ùˆ Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ)
// =================================================================================

export default {
    async fetch(request, env, ctx) {
        const url = new URL(request.url);
        // Routing API requests
        if (url.pathname === '/api/leaderboard') {
            return await handleApiRequest(request, env);
        }
        if (url.pathname.startsWith('/api/user/')) {
            return await handleUserApiRequest(request, env);
        }

        // Handling Telegram updates
        try {
            const contentType = request.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                if (env.REAL_BOT_HOST_URL) {
                    ctx.waitUntil(forwardRawBody(request, "", env.REAL_BOT_HOST_URL));
                }
                return new Response('OK');
            }
            const rawBody = await request.text();
            if (!rawBody) return new Response('OK');
            if (env.REAL_BOT_HOST_URL) {
                ctx.waitUntil(forwardRawBody(request, rawBody, env.REAL_BOT_HOST_URL));
            }
            const update = JSON.parse(rawBody);
            const bot = new TelegramBot(env.BOT_TOKEN);
            if (update.channel_post) {
                await handleChannelPost(update.channel_post, env, bot);
            } else if (update.callback_query) {
                await handleCallbackQuery(update.callback_query, env, bot);
            } else if (update.message) {
                await handleMessage(update.message, env, bot);
            }
        } catch (e) {
            console.error("Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´Ú¯Ø± Ø§ØµÙ„ÛŒ:", e.toString());
        }
        return new Response('OK');
    },
    async scheduled(controller, env, ctx) {
        console.log("Cron Trigger: Ø´Ø±ÙˆØ¹ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯...");
        ctx.waitUntil(updateLeaderboardCache(env));
    }
};

async function handleUserApiRequest(request, env) {
    const url = new URL(request.url);
    const userId = url.pathname.split('/').pop();
    const headers = { 'Content-Type': 'application/json;charset=UTF-8', 'Access-Control-Allow-Origin': '*' };

    if (!userId || isNaN(userId)) {
        return new Response(JSON.stringify({ error: "User ID provided is invalid." }), { status: 400, headers });
    }

    const userData = await env.CONTEST_DB.get(`user_${userId}`, { type: 'json' });

    if (!userData) {
        return new Response(JSON.stringify({ error: "User not found." }), { status: 404, headers });
    }

    const cachedLeaderboard = await env.CONTEST_DB.get('leaderboard_cache', { type: 'json' });
    let rank = -1;
    if (cachedLeaderboard) {
        const userIndex = cachedLeaderboard.findIndex(u => u.id == userId);
        if (userIndex !== -1) {
            rank = userIndex + 1;
        }
    }

    const responseData = {
        id: userId,
        username: userData.username || null,
        first_name: userData.first_name || 'Ú©Ø§Ø±Ø¨Ø±',
        points: userData.points || 0,
        rank: rank
    };

    return new Response(JSON.stringify(responseData), { status: 200, headers });
}


async function handleApiRequest(request, env) {
    const cachedLeaderboard = await env.CONTEST_DB.get('leaderboard_cache', { type: 'json' });
    if (!cachedLeaderboard) {
        return new Response(JSON.stringify({ error: "Ù„ÛŒØ³Øª Ù†ÙØ±Ø§Øª Ø¨Ø±ØªØ± Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ú†Ù†Ø¯ Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯ÛŒÚ¯Ø± ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯." }), {
            status: 404,
            headers: { 'Content-Type': 'application/json;charset=UTF-8', 'Access-Control-Allow-Origin': '*' },
        });
    }
    return new Response(JSON.stringify(cachedLeaderboard), {
        status: 200,
        headers: { 'Content-Type': 'application/json;charset=UTF-8', 'Access-Control-Allow-Origin': '*', 'Cache-Control': 'public, max-age=60' },
    });
}

async function updateLeaderboardCache(env) {
    try {
        if (!env.CONTEST_DB) {
            throw new Error("Ø¯ÛŒØªØ§Ø¨ÛŒØ³ (KV Namespace) Ø¨Ø§ Ù†Ø§Ù… CONTEST_DB Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ù…ØªØµÙ„ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
        }
        let allKeys = [];
        let listComplete = false;
        let cursor = undefined;
        while (!listComplete) {
            const result = await env.CONTEST_DB.list({ limit: 1000, cursor: cursor });
            allKeys = allKeys.concat(result.keys);
            listComplete = result.list_complete;
            cursor = result.cursor;
        }
        const promises = allKeys
            .filter(key => key.name.startsWith('user_'))
            .map(key =>
                env.CONTEST_DB.get(key.name, { type: 'json' })
                .then(value => (value && value.points > 0) ? {
                    id: key.name.replace('user_', ''),
                    username: value.username || null,
                    first_name: value.first_name || `Ú©Ø§Ø±Ø¨Ø±`,
                    points: value.points || 0
                } : null)
                .catch(e => { console.error(`Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ù„ÛŒØ¯ ${key.name}: ${e.message}`); return null; })
            );
        const results = await Promise.all(promises);
        let users = results.filter(user => user !== null);
        users.sort((a, b) => b.points - a.points);
        const top100 = users.slice(0, 100);
        await env.CONTEST_DB.put('leaderboard_cache', JSON.stringify(top100));
        console.log(`Ú©Ø´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯. (${top100.length} Ú©Ø§Ø±Ø¨Ø± Ø¨Ø±ØªØ± Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù†Ø¯)`);
        return { success: true, error: null };
    } catch (e) {
        console.error("Ø®Ø·Ø§ÛŒ Ø¬Ø¯ÛŒ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯:", e.toString());
        return { success: false, error: e.toString() };
    }
}

async function handleMessage(message, env, bot) {
    const userId = message.from.id;
    const username = message.from.username || `user_${userId}`;
    const firstName = message.from.first_name || `Ú©Ø§Ø±Ø¨Ø±`;
    const text = message.text || '';
    
    let userData = await env.CONTEST_DB.get(`user_${userId}`, { type: 'json' }) || createDefaultUserData(username, firstName);
    let dataChanged = false;

    if (userData.username !== username || userData.first_name !== firstName) {
        userData.username = username;
        userData.first_name = firstName;
        dataChanged = true;
    }
    
    if (text === '/admin_update_cache') {
        if (userId.toString() === env.ADMIN_USER_ID) {
            await bot.sendMessage(userId, "â³ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÛŒ Ú©Ø´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯.");
            const { success, error } = await updateLeaderboardCache(env);
            if (success) {
                await bot.sendMessage(userId, "âœ… Ú©Ø´ Ù„ÛŒØ¯Ø±Ø¨Ø±Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯.");
            } else {
                await bot.sendMessage(userId, `âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø´:\n\n<code>${error}</code>`);
            }
        } else {
            await bot.sendMessage(userId, "Ø´Ù…Ø§ Ø§Ø¬Ø§Ø²Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯.");
        }
        return;
    }

    if (text === '/leaderboard') {
        const leaderboardUrl = `https://amirrezahoseinabadi.github.io/DASH?user_id=${userId}`; 
        const messageText = `ğŸ† Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¬Ø¯ÙˆÙ„ Ú©Ø§Ù…Ù„ Ùˆ Ø¨Ù‡â€ŒØ±ÙˆØ² Ù†ÙØ±Ø§Øª Ø¨Ø±ØªØ±ØŒ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:`;
        const keyboard = {
            inline_keyboard: [
                [{ text: "ğŸš€ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¬Ø¯ÙˆÙ„ Ù†ÙØ±Ø§Øª Ø¨Ø±ØªØ±", web_app: { url: leaderboardUrl } }]
            ]
        };
        await bot.sendMessage(userId, messageText, keyboard);
        return;
    }

    if (text.startsWith('/start')) {
        const parts = text.split(' ');
        const startPayload = parts.length > 1 ? parts[1] : null;

        if (startPayload && startPayload == userId) {
            const funnyMessage = "Ø¯Ø§Ø¯Ø§Ø´ Ø¯Ø§Ø±ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ù…ÛŒØ²Ù†ÛŒ! Ú†Ø±Ø§ Ù‚ÛŒÙ…Ù‡â€ŒÙ‡Ø§ Ø±Ùˆ Ù…ÛŒâ€ŒØ±ÛŒØ²ÛŒ ØªÙˆ Ù…Ø§Ø³Øªâ€ŒÙ‡Ø§ØŸ ğŸ¤”\n\nÙ†Ù…ÛŒØ´Ù‡ Ú©Ù‡ Ø®ÙˆØ¯Øª Ø²ÛŒØ±Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø®ÙˆØ¯Øª Ø¨Ø´ÛŒ! Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Ø±Ùˆ Ø¨Ø±Ø§ÛŒ Ø¯ÙˆØ³ØªØ§Øª Ø¨ÙØ±Ø³Øª.";
            await bot.sendMessage(userId, funnyMessage);
            const welcomeMessage = "ğŸ‘‡ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª Ø§Ø®ØªØµØ§ØµÛŒ Ø®ÙˆØ¯ØŒ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.";
            const keyboard = { inline_keyboard: [ [{ text: "ğŸ”— Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª", callback_data: "request_referral_link" }] ] };
            await bot.sendMessage(userId, welcomeMessage, keyboard);
        
        } else if (startPayload === 'promo_channel') {
                const promoMessage = "ğŸ‰ Ø¨Ù‡ Ú©Ù…Ù¾ÛŒÙ† ÙˆÛŒÚ˜Ù‡ Ù…Ø§ Ø§Ø² Ú©Ø§Ù†Ø§Ù„ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯! ğŸ‰\n\nØ¨Ø±Ø§ÛŒ Ø´Ø±Ú©Øª Ø¯Ø± Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ Ùˆ Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª Ø§Ø®ØªØµØ§ØµÛŒ Ø®ÙˆØ¯ØŒ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.";
                const keyboard = { inline_keyboard: [ [{ text: "ğŸ”— Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª", callback_data: "request_referral_link" }] ] };
                await bot.sendMessage(userId, promoMessage, keyboard);

        } else if (startPayload && !isNaN(startPayload) && !userData.referrer_id) {
                const referrerId = startPayload;
                let referrerData = await env.CONTEST_DB.get(`user_${referrerId}`, { type: 'json' }) || createDefaultUserData();
                
                referrerData.referrals_count = (referrerData.referrals_count || 0) + 1;
                await env.CONTEST_DB.put(`user_${referrerId}`, JSON.stringify(referrerData));
                
                userData.referrer_id = referrerId;
                dataChanged = true;
                
                const messageForReferrer = `ğŸ‘‹ Ú©Ø§Ø±Ø¨Ø± <b>${firstName}</b> Ø¯Ø¹ÙˆØª Ø´Ù…Ø§ Ø±Ø§ Ù¾Ø°ÛŒØ±ÙØª! Ù¾Ø³ Ø§Ø² Ø§ÙˆÙ„ÛŒÙ† Ø®Ø±ÛŒØ¯ØŒ Ø§Ù…ØªÛŒØ§Ø² Ø´Ù…Ø§ Ø«Ø¨Øª Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.`;
                await bot.sendMessage(referrerId, messageForReferrer);
                
                const messageForNewbie = `â˜€ï¸ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯! â˜€ï¸\n\nØ´Ù…Ø§ ØªÙˆØ³Ø· <b>${referrerData.first_name || 'Ø¯ÙˆØ³ØªØªØ§Ù†'}</b> Ø¯Ø¹ÙˆØª Ø´Ø¯Ù‡â€ŒØ§ÛŒØ¯! Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.`;
                const keyboard = { inline_keyboard: [ [{ text: "ğŸ”— Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª", callback_data: "request_referral_link" }] ] };
                await bot.sendMessage(userId, messageForNewbie, keyboard);
            
        }
    
    } else if (text === '/mypoints') {
        await sendMyPointsMessage(userId, env, bot);
    }
    
    if (dataChanged) {
        await env.CONTEST_DB.put(`user_${userId}`, JSON.stringify(userData));
    }
}

async function handleChannelPost(post, env, bot) { 
    if (!post || !post.chat || !post.chat.id) return; 
    const receivedChannelId = post.chat.id.toString(); 
    const expectedChannelId = env.REPORT_CHANNEL_ID ? env.REPORT_CHANNEL_ID.trim() : null; 
    if (receivedChannelId !== expectedChannelId) return; 
    const messageText = post.text || ''; 
    if (messageText.includes('#Ø³ÙØ§Ø±Ø´_Ø¬Ø¯ÛŒØ¯') || messageText.includes('#Ø®Ø¯Ù…Ø§Øª_Ø³Ø§Ø¨')) { 
        const buyerId = parseUserId(messageText); 
        if (!buyerId) return; 
        let buyerData = await env.CONTEST_DB.get(`user_${buyerId}`, { type: 'json' }) || createDefaultUserData(); 
        let pointsEarned = 1; 
        if (!buyerData.first_purchase_done && buyerData.referrer_id) { 
            pointsEarned += 3; 
            const referrerId = buyerData.referrer_id; 
            let referrerData = await env.CONTEST_DB.get(`user_${referrerId}`, { type: 'json' }) || createDefaultUserData(); 
            referrerData.points = (referrerData.points || 0) + 3; 
            referrerData.referrals_who_purchased_count = (referrerData.referrals_who_purchased_count || 0) + 1; 
            await env.CONTEST_DB.put(`user_${referrerId}`, JSON.stringify(referrerData)); 
            const buyerUsername = parseUsername(messageText); 
            const buyerDisplayUsername = buyerUsername ? `@${buyerUsername}` : `Ú©Ø§Ø±Ø¨Ø± ${buyerId}`; 
            const messageForReferrer = `ğŸ ØªØ¨Ø±ÛŒÚ©! Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú©Ù‡ Ø¯Ø¹ÙˆØª Ú©Ø±Ø¯Ù‡ Ø¨ÙˆØ¯ÛŒØ¯ (${buyerDisplayUsername}) Ø§ÙˆÙ„ÛŒÙ† Ø®Ø±ÛŒØ¯ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ø§Ø¯ Ùˆ <b>Û³ Ø§Ù…ØªÛŒØ§Ø²</b> Ø¨Ù‡ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯!\n/mypoints`; 
            await bot.sendMessage(referrerId, messageForReferrer); 
        } 
        buyerData.points = (buyerData.points || 0) + pointsEarned; 
        buyerData.first_purchase_done = true; 
        const username = parseUsername(messageText); 
        if (username) buyerData.username = username; 
        await env.CONTEST_DB.put(`user_${buyerId}`, JSON.stringify(buyerData)); 
        const keyboard = { inline_keyboard: [ [{ text: "ğŸ“Š Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¢Ù…Ø§Ø± Ø§Ù…ØªÛŒØ§Ø²Ø§Øª", callback_data: "show_mypoints" }] ] }; 
        const confirmationMessage = `âœ… Ø®Ø±ÛŒØ¯ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯ Ùˆ <b>${pointsEarned} Ø§Ù…ØªÛŒØ§Ø²</b> Ø¯Ø±ÛŒØ§ÙØª Ú©Ø±Ø¯ÛŒØ¯!\n\nÙ…Ø¬Ù…ÙˆØ¹ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª: <b>${buyerData.points}</b>`; 
        await bot.sendMessage(buyerId, confirmationMessage, keyboard); 
    } 
}

async function handleCallbackQuery(callbackQuery, env, bot) { 
    const userId = callbackQuery.from.id; 
    const username = callbackQuery.from.username || `user_${userId}`; 
    const firstName = callbackQuery.from.first_name || 'Ú©Ø§Ø±Ø¨Ø±'; 
    if (callbackQuery.data === 'request_referral_link') { 
        let userData = await env.CONTEST_DB.get(`user_${userId}`, { type: 'json' }) || createDefaultUserData(username, firstName); 
        if (!userData.referral_link) { 
            userData.referral_link = `https://t.me/${env.BOT_USERNAME}?start=${userId}`; 
        } 
        userData.username = username; 
        userData.first_name = firstName; 
        await env.CONTEST_DB.put(`user_${userId}`, JSON.stringify(userData)); 

        const bannerText = `<b>â˜ï¸ - Ø¢Ù‚Ø§ÛŒ Ù…Ø±Ø²Ø¨Ø§Ù† : Ù¾Ù†Ù„ Ø³Ø§Ø² Ø®ÙˆØ¯Ú©Ø§Ø±</b>

<i>Ø¬Ø§Ù…Ø¹ ØªØ±ÛŒÙ† Ø±Ø¨Ø§Øª Ùˆ Ø§ÙˆÙ„ÛŒÙ† Ù¾Ù†Ù„ Ø³Ø§Ø² Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ­Øª ØªÙ„Ú¯Ø±Ø§Ù… Ú©Ù‡ Ø³Ø¹ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ø§Ù‡Ø´ Ú†Ø´Ù…Ú¯ÛŒØ± Ù‡Ø²ÛŒÙ†Ù‡ Ù‡Ø§Ø±Ø§ Ø¨Ø±Ø§ÛŒ ÙØ±ÙˆØ´Ù†Ø¯Ú¯Ø§Ù† ØªØ¬Ø§Ø±ÛŒ Ùˆ Ù…ØµØ§Ø±Ù Ø®Ø§Ù†Ú¯ÛŒ Ø¨Ù‡ Ø§Ø±Ù…ØºØ§Ù† Ø¨ÛŒØ§ÙˆØ±Ø¯.</i>
<blockquote>â™¾ï¸ - <b>Ø§Ù…Ú©Ø§Ù†Ø§Øª ÙÙˆÙ‚ Ø­Ø±ÙÙ‡ Ø§ÛŒ</b>
ğŸš© - Ø´Ø±ÙˆØ¹ Ù‚ÛŒÙ…Øª Ø§Ø² 375 ØªÙˆÙ…Ø§Ù†Â 
ğŸ”µ - Ø±ÛŒØ³ØªØ§Ø±Øª Ù¾Ù†Ù„ Ù…Ø±Ø²Ø¨Ø§Ù† Ø¨Ø§ ÛŒÚ© Ú©Ù„ÛŒÚ©
âš¡ï¸ - Ø®Ø§Ù…ÙˆØ´/Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø§Ø´ØªØ±Ø§Ú© Ù‡Ø§
ğŸŒ - Ø¢Ù¾ ØªØ§ÛŒÙ…Â  99% Ø¯Ø±ØµØ¯ÛŒ
ğŸ”¥ - Ø¯ÛŒØªØ§Ø³Ù†ØªØ± : Ø¢Ù„Ù…Ø§Ù†-ÙÙ†Ù„Ø§Ù†Ø¯-Ø§Ù†Ú¯Ù„ÛŒØ³-ÙØ±Ø§Ù†Ø³Ù‡
â™»ï¸ - Ø¨Ø¯ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø³Ø±ÙˆØ± Ø®Ø§Ø±Ø¬/Ø§ÛŒØ±Ø§Ù†
ğŸ‘¤ - Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ ÙØ¹Ø§Ù„ Ùˆ 24 Ø³Ø§Ø¹ØªÙ‡
ğŸ” - ØªØºÛŒÛŒØ± Ù¾Ø³ÙˆØ±Ø¯ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾Ù†Ù„ Ù…Ø±Ø²Ø¨Ø§Ù†
ğŸ· - Ø¨Ø¯ÙˆÙ† Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ùˆ Ø¯Ø±Ø¯Ø³Ø±</blockquote>
ğŸ†• <b>ØªØ³Øª Ø±Ø§ÛŒÚ¯Ø§Ù† :</b> ÛŒÚ© Ù¾Ù†Ù„ Ù…Ø±Ø²Ø¨Ø§Ù† Ø¨Ø§ 15 Ú¯ÛŒÚ¯Ø§Ø¨Ø§ÛŒØª ØªØ±Ø§ÙÛŒÚ© Ø±Ø§ÛŒÚ¯Ø§Ù† Ùˆ Ø§Ù†Ù‚Ø¶Ø§ Ù†Ø§Ù…Ø­Ø¯ÙˆØ¯ Ø§Ø² Ø±Ø¨Ø§Øª Ù…Ø§ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø±Ø¯Ù‡ Ùˆ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯. ÙØ±ØµØª Ø±Ø§ Ø§Ø²Â  Ø¯Ø³Øª Ù†Ø¯Ù‡ÛŒØ¯ Ùˆ Ù‡Ù…ÛŒÙ† Ø­Ø§Ù„Ø§ Ø§Ù‚Ø¯Ø§Ù… Ú©Ù†ÛŒØ¯...Â 

ğŸ“£ - @MarzbanMR
ğŸ“ - @MarzbanMRBot`;

        const keyboard = {
            inline_keyboard: [
                [{ text: "ğŸ”· Ø§Ø³ØªØ§Ø±Øª Ø±Ø¨Ø§Øª ğŸ”·", url: userData.referral_link }]
            ]
        };

        await bot.sendMessage(userId, bannerText, keyboard);
        
        const linkMessage = `Ø¯Ú©Ù…Ù‡ Ø´ÛŒØ´Ù‡ Ø§ÛŒ Ø¨Ø§Ù„Ø§ Ù…Ø¬Ù‡Ø² Ø¨Ù‡ Ù„ÛŒÙ†Ú© Ø§Ø®ØªØµØ§ØµÛŒ Ø´Ù…Ø§Ø³Øª Ø§Ù…Ø§ Ø¨Ø§ Ø§ÛŒÙ† Ø­Ø§Ù„ğŸ‰ Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª Ø§Ø®ØªØµØ§ØµÛŒ Ø´Ù…Ø§:

<code>${userData.referral_link}</code>

<i>Ø±ÙˆÛŒ Ù„ÛŒÙ†Ú© Ø¨Ø§Ù„Ø§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØªØ§ Ú©Ù¾ÛŒ Ø´ÙˆØ¯</i>`;

        await bot.sendMessage(userId, linkMessage);


    } else if (callbackQuery.data === 'show_mypoints') { 
        await sendMyPointsMessage(userId, env, bot); 
    } 
    await bot.answerCallbackQuery(callbackQuery.id); 
}

async function sendMyPointsMessage(userId, env, bot) {
    const userData = await env.CONTEST_DB.get(`user_${userId}`, { type: 'json' }) || createDefaultUserData();
    const points = userData.points || 0;
    const referrals = userData.referrals_count || 0;
    const purchased_referrals = userData.referrals_who_purchased_count || 0;
    
    const leaderboardBaseUrl = "https://amirrezahoseinabadi.github.io/DASH";
    const webAppUrl = `${leaderboardBaseUrl}?user_id=${userId}`;
    const shareText = encodeURIComponent("Ø§Ù…ØªÛŒØ§Ø² Ù…Ù† Ø¯Ø± Ø¬Ø´Ù†ÙˆØ§Ø±Ù‡ Ø¨Ø²Ø±Ú¯ Ø¢Ù‚Ø§ÛŒ Ù…Ø±Ø²Ø¨Ø§Ù† Ø±Ùˆ Ø¨Ø¨ÛŒÙ†! ØªÙˆ Ù‡Ù… Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø¨Ø±Ù†Ø¯Ù‡ Ø¨Ø§Ø´ÛŒ ğŸ”¥");
    const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(webAppUrl)}&text=${shareText}`;

    const keyboard = {
        inline_keyboard: [
            [{ text: "ğŸ† Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¬Ø¯ÙˆÙ„ Ù†ÙØ±Ø§Øª Ø¨Ø±ØªØ±", web_app: { url: webAppUrl } }],
            [{ text: "ğŸš€ Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§Ù…ØªÛŒØ§Ø² Ù…Ù†", url: shareUrl }]
        ]
    };
    const messageText = `ğŸ“Š <b>Ø¢Ù…Ø§Ø± Ø´Ù…Ø§ Ø¯Ø± Ø¬Ø´Ù†ÙˆØ§Ø±Ù‡</b>:\n\n- ğŸ’° Ø§Ù…ØªÛŒØ§Ø²Ø§Øª: <b>${points}</b>\n- ğŸ‘¥ Ø¯Ø¹ÙˆØªâ€ŒÙ‡Ø§: <b>${referrals}</b>\n- âœ… Ø¯Ø¹ÙˆØªâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙÙ‚: <b>${purchased_referrals}</b>`;
    await bot.sendMessage(userId, messageText, keyboard);
}


function createDefaultUserData(username = '', firstName = '') { 
    return { points: 0, username: username, first_name: firstName, referral_link: '', referrer_id: null, first_purchase_done: false, referrals_count: 0, referrals_who_purchased_count: 0 }; 
}

async function forwardRawBody(originalRequest, rawBody, hostUrl) { 
    try { 
        await fetch(hostUrl, { method: originalRequest.method, headers: originalRequest.headers, body: rawBody, }); 
    } catch (e) { 
        console.error("Ø®Ø·Ø§ Ø¯Ø± ÙÙˆØ±ÙˆØ§Ø±Ø¯:", e.toString()); 
    } 
}

class TelegramBot { 
    constructor(token) { 
        this.token = token; 
        this.apiUrl = `https://api.telegram.org/bot${token}`; 
    } 
    async sendMessage(chatId, text, replyMarkup = null) { 
        const payload = { chat_id: chatId, text: text, parse_mode: 'HTML' }; 
        if (replyMarkup) { 
            payload.reply_markup = replyMarkup; 
        } 
        await fetch(`${this.apiUrl}/sendMessage`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), }); 
    } 
    async answerCallbackQuery(callbackQueryId) { 
        await fetch(`${this.apiUrl}/answerCallbackQuery`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ callback_query_id: callbackQueryId }), }); 
    } 
}

function parseUserId(text) { 
    const match = text.match(/(?:id|Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ ÙØ±Ø¯)\s*:\s*(\d+)/); 
    return match ? match[1] : null; 
}

function parseUsername(text) { 
    const match = text.match(/Ø¢ÛŒØ¯ÛŒ ÙØ±Ø¯\s*:\s*@(\w+)/); 
    return match ? match[1] : null; 
}
